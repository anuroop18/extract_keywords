# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['read_in_text', 'is_word_in_range', 'remove_singular_words', 'word_contains_numbers',
           'remove_duplicates_preserve_order', 'split_compound_words', 'contains_only_alphabets', 'generate_keywords']

# %% ../nbs/00_core.ipynb 3
import pandas as pd
import numpy as np
from sentence_transformers import SentenceTransformer
from keybert import KeyBERT
from keyphrase_vectorizers import KeyphraseCountVectorizer
from functools import partial
import re

# %% ../nbs/00_core.ipynb 4
def read_in_text(file_path:str): # path of text file
    "Read in the text file"
    with open(file_path, 'r') as f: return f.read()

# %% ../nbs/00_core.ipynb 5
def is_word_in_range(word:str, # input word
                     min_len:int, # Min length of word
                     max_len:int): # Max length of word
    "returns True if word is in range (min_len, max_len) both inclusive"
    if (len(word) <= max_len) and (len(word) >= min_len): return True
    else: return False

# %% ../nbs/00_core.ipynb 12
def remove_singular_words(word_list:list): # List of words
    "Removes singular words when they have a corresponding plural word in a list of words."
    plural_words = set()
    singular_words = []
    
    for word in word_list:
        # Check if the word is in plural form by adding 's'
        plural_form = word + 's'
        
        if plural_form in word_list:
            # If the plural form is in the list, add it to the set of plural words
            plural_words.add(plural_form)
        else:
            # If the word is not in plural form, add it to the list of singular words
            singular_words.append(word)
    
    return singular_words

# %% ../nbs/00_core.ipynb 15
def word_contains_numbers(word:str): # input word
    "returns True if word contains numbers, False otherwise."
    return any(char.isdigit() for char in word)        

# %% ../nbs/00_core.ipynb 19
def remove_duplicates_preserve_order(input_list:list):
    "removes duplicate items from a list while preserving order"
    return [x for i, x in enumerate(input_list) if x not in input_list[:i]]

# %% ../nbs/00_core.ipynb 21
def split_compound_words(input_list:list): # list of words
    "returns a new list made after splitting all the compound words, removing duplicate items. Preserves order."
    result = []
    for item in input_list: result.extend(item.split())
    result = remove_duplicates_preserve_order(result)
    return result

# %% ../nbs/00_core.ipynb 23
def contains_only_alphabets(input_string:str):
    "returns False if string contains anything other than alphabets"
    # Define the regular expression pattern to match anything other than alphabets
    pattern = r'[^a-zA-Z]'
    
    # Search for the pattern in the input string
    if re.search(pattern, input_string):return False
    else:return True
    

# %% ../nbs/00_core.ipynb 25
def generate_keywords(text:str, # input text
                      max_len:int, # maximum length of word
                     n:int=10, # number of keywords
                     min_len:int=3, # minimum length of word
                      compound_words=True, # include combination of words
                    only_alphabets=True): # include those keywords that contain alphabets only
    "Extract n keywords from text in range (min_len, max_len) both inclusive. if `only_alphabets` is True, `compound_words` is False"
    if only_alphabets: compound_words=False
    kw_extractor = KeyBERT('valurank/MiniLM-L6-Keyword-Extraction')
    keywords = kw_extractor.extract_keywords(text, vectorizer=KeyphraseCountVectorizer(), stop_words=None, top_n=n*2)
    keywords = [i for i,j in keywords] #removing confidence score
    if compound_words is False: keywords = split_compound_words(keywords) #removing compound words
    if only_alphabets: keywords = [word for word in keywords if contains_only_alphabets(word)] #removing keywords with numbers and special characters
    keywords = remove_singular_words(keywords) #removing one of singluar/plural combination
    keywords = [word for word in keywords if is_word_in_range(word, min_len=min_len, max_len=max_len)] #removing words that are out of range
    return keywords[:n]
